// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: game.proto

/*
	Package protoMsg is a generated protocol buffer package.

	It is generated from these files:
		game.proto

	It has these top-level messages:
		C_ClientLog
		C_UserLocation
		C_ShareInfo
		S_GetServerTime
		C_LoginServer
		SharingInfo
		UserInfo
		S_LoginServer
		C_GameServer
		S_GameServer
		C_AccountInfo
		S_AccountInfo
		C_ChrList
		S_ChrList
		C_NewChr
		S_NewChr
		C_GetName
		S_GetName
		C_PlayerAbility
		BaseAbility
		S_PlayerAbility
		C_ChangeMap
		S_ChangeMap
		C_GetBagItems
		BagItem
		S_GetBagItems
		C_GetEquips
		EquipItem
		S_GetEquips
		C_GetSkills
		SkillItem
		S_GetSkills
*/
package protoMsg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type C_CMD int32

const (
	C_CMD_C_INIT          C_CMD = 0
	C_CMD_C_GETSERVERTIME C_CMD = 5000
	C_CMD_C_CLIENTLOG     C_CMD = 5001
	C_CMD_C_CLIENTCOMMAND C_CMD = 5002
	C_CMD_C_USERLOCATION  C_CMD = 5003
	C_CMD_C_SHAREINFO     C_CMD = 5004
	C_CMD_C_HEARTBEST     C_CMD = 5999
	C_CMD_C_LOGINSERVER   C_CMD = 6000
	C_CMD_C_GAMESERVER    C_CMD = 6001
	C_CMD_C_ACCOUNTINFO   C_CMD = 6002
	C_CMD_C_CHRLIST       C_CMD = 6003
	C_CMD_C_NEWCHR        C_CMD = 6005
	C_CMD_C_GETNAME       C_CMD = 6006
	C_CMD_C_PLAYERABILITY C_CMD = 6007
	C_CMD_C_CHANGEMAP     C_CMD = 6008
	C_CMD_C_GETBAGITEMS   C_CMD = 6009
	C_CMD_C_GETEQUIPS     C_CMD = 6010
	C_CMD_C_GETSKILLS     C_CMD = 6011
	C_CMD_C_USEITEM       C_CMD = 6012
	C_CMD_C_ADDITEM       C_CMD = 6013
	C_CMD_C_DELETEITEM    C_CMD = 6014
	C_CMD_C_TAKEONEQUIP   C_CMD = 6015
	C_CMD_C_TAKEOFFEQUIP  C_CMD = 6016
	C_CMD_C_DROPUPEQUIP   C_CMD = 6017
	C_CMD_C_ONLINEINCOME  C_CMD = 6018
	C_CMD_C_OFFLINEINCOME C_CMD = 6019
	C_CMD_C_MAPBOSS       C_CMD = 6026
)

var C_CMD_name = map[int32]string{
	0:    "C_INIT",
	5000: "C_GETSERVERTIME",
	5001: "C_CLIENTLOG",
	5002: "C_CLIENTCOMMAND",
	5003: "C_USERLOCATION",
	5004: "C_SHAREINFO",
	5999: "C_HEARTBEST",
	6000: "C_LOGINSERVER",
	6001: "C_GAMESERVER",
	6002: "C_ACCOUNTINFO",
	6003: "C_CHRLIST",
	6005: "C_NEWCHR",
	6006: "C_GETNAME",
	6007: "C_PLAYERABILITY",
	6008: "C_CHANGEMAP",
	6009: "C_GETBAGITEMS",
	6010: "C_GETEQUIPS",
	6011: "C_GETSKILLS",
	6012: "C_USEITEM",
	6013: "C_ADDITEM",
	6014: "C_DELETEITEM",
	6015: "C_TAKEONEQUIP",
	6016: "C_TAKEOFFEQUIP",
	6017: "C_DROPUPEQUIP",
	6018: "C_ONLINEINCOME",
	6019: "C_OFFLINEINCOME",
	6026: "C_MAPBOSS",
}
var C_CMD_value = map[string]int32{
	"C_INIT":          0,
	"C_GETSERVERTIME": 5000,
	"C_CLIENTLOG":     5001,
	"C_CLIENTCOMMAND": 5002,
	"C_USERLOCATION":  5003,
	"C_SHAREINFO":     5004,
	"C_HEARTBEST":     5999,
	"C_LOGINSERVER":   6000,
	"C_GAMESERVER":    6001,
	"C_ACCOUNTINFO":   6002,
	"C_CHRLIST":       6003,
	"C_NEWCHR":        6005,
	"C_GETNAME":       6006,
	"C_PLAYERABILITY": 6007,
	"C_CHANGEMAP":     6008,
	"C_GETBAGITEMS":   6009,
	"C_GETEQUIPS":     6010,
	"C_GETSKILLS":     6011,
	"C_USEITEM":       6012,
	"C_ADDITEM":       6013,
	"C_DELETEITEM":    6014,
	"C_TAKEONEQUIP":   6015,
	"C_TAKEOFFEQUIP":  6016,
	"C_DROPUPEQUIP":   6017,
	"C_ONLINEINCOME":  6018,
	"C_OFFLINEINCOME": 6019,
	"C_MAPBOSS":       6026,
}

func (x C_CMD) String() string {
	return proto.EnumName(C_CMD_name, int32(x))
}
func (C_CMD) EnumDescriptor() ([]byte, []int) { return fileDescriptorGame, []int{0} }

type S_CMD int32

const (
	S_CMD_S_INIT          S_CMD = 0
	S_CMD_S_GETSERVERTIME S_CMD = 5000
	S_CMD_S_LOGINSERVER   S_CMD = 6000
	S_CMD_S_GAMESERVER    S_CMD = 6001
	S_CMD_S_ACCOUNTINFO   S_CMD = 6002
	S_CMD_S_CHRLIST       S_CMD = 6003
	S_CMD_S_NEWCHR        S_CMD = 6005
	S_CMD_S_GETNAME       S_CMD = 6006
	S_CMD_S_PLAYERABILITY S_CMD = 6007
	S_CMD_S_CHANGEMAP     S_CMD = 6008
	S_CMD_S_GETBAGITEMS   S_CMD = 6009
	S_CMD_S_GETEQUIPS     S_CMD = 6010
	S_CMD_S_GETSKILLS     S_CMD = 6011
	S_CMD_S_USEITEM       S_CMD = 6012
	S_CMD_S_ADDITEM       S_CMD = 6013
	S_CMD_S_DELETEITEM    S_CMD = 6014
	S_CMD_S_TAKEONEQUIP   S_CMD = 6015
	S_CMD_S_TAKEOFFEQUIP  S_CMD = 6016
	S_CMD_S_DROPUPEQUIP   S_CMD = 6017
	S_CMD_S_ONLINEINCOME  S_CMD = 6018
	S_CMD_S_OFFLINEINCOME S_CMD = 6019
	S_CMD_S_LEVELUP       S_CMD = 6020
	S_CMD_S_ATTRIBCHANGE  S_CMD = 6021
	S_CMD_S_WEATHCHANGE   S_CMD = 6022
	S_CMD_S_OUTLOOKCHANGE S_CMD = 6023
	S_CMD_S_BAGCHANGE     S_CMD = 6024
	S_CMD_S_SKILLCHANGE   S_CMD = 6025
	S_CMD_S_MAPBOSS       S_CMD = 6026
)

var S_CMD_name = map[int32]string{
	0:    "S_INIT",
	5000: "S_GETSERVERTIME",
	6000: "S_LOGINSERVER",
	6001: "S_GAMESERVER",
	6002: "S_ACCOUNTINFO",
	6003: "S_CHRLIST",
	6005: "S_NEWCHR",
	6006: "S_GETNAME",
	6007: "S_PLAYERABILITY",
	6008: "S_CHANGEMAP",
	6009: "S_GETBAGITEMS",
	6010: "S_GETEQUIPS",
	6011: "S_GETSKILLS",
	6012: "S_USEITEM",
	6013: "S_ADDITEM",
	6014: "S_DELETEITEM",
	6015: "S_TAKEONEQUIP",
	6016: "S_TAKEOFFEQUIP",
	6017: "S_DROPUPEQUIP",
	6018: "S_ONLINEINCOME",
	6019: "S_OFFLINEINCOME",
	6020: "S_LEVELUP",
	6021: "S_ATTRIBCHANGE",
	6022: "S_WEATHCHANGE",
	6023: "S_OUTLOOKCHANGE",
	6024: "S_BAGCHANGE",
	6025: "S_SKILLCHANGE",
	6026: "S_MAPBOSS",
}
var S_CMD_value = map[string]int32{
	"S_INIT":          0,
	"S_GETSERVERTIME": 5000,
	"S_LOGINSERVER":   6000,
	"S_GAMESERVER":    6001,
	"S_ACCOUNTINFO":   6002,
	"S_CHRLIST":       6003,
	"S_NEWCHR":        6005,
	"S_GETNAME":       6006,
	"S_PLAYERABILITY": 6007,
	"S_CHANGEMAP":     6008,
	"S_GETBAGITEMS":   6009,
	"S_GETEQUIPS":     6010,
	"S_GETSKILLS":     6011,
	"S_USEITEM":       6012,
	"S_ADDITEM":       6013,
	"S_DELETEITEM":    6014,
	"S_TAKEONEQUIP":   6015,
	"S_TAKEOFFEQUIP":  6016,
	"S_DROPUPEQUIP":   6017,
	"S_ONLINEINCOME":  6018,
	"S_OFFLINEINCOME": 6019,
	"S_LEVELUP":       6020,
	"S_ATTRIBCHANGE":  6021,
	"S_WEATHCHANGE":   6022,
	"S_OUTLOOKCHANGE": 6023,
	"S_BAGCHANGE":     6024,
	"S_SKILLCHANGE":   6025,
	"S_MAPBOSS":       6026,
}

func (x S_CMD) String() string {
	return proto.EnumName(S_CMD_name, int32(x))
}
func (S_CMD) EnumDescriptor() ([]byte, []int) { return fileDescriptorGame, []int{1} }

// log [5001]
type C_ClientLog struct {
	Kind     uint32 `protobuf:"varint,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Behavior uint32 `protobuf:"varint,2,opt,name=behavior,proto3" json:"behavior,omitempty"`
	Param    string `protobuf:"bytes,3,opt,name=param,proto3" json:"param,omitempty"`
}

func (m *C_ClientLog) Reset()                    { *m = C_ClientLog{} }
func (m *C_ClientLog) String() string            { return proto.CompactTextString(m) }
func (*C_ClientLog) ProtoMessage()               {}
func (*C_ClientLog) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{0} }

func (m *C_ClientLog) GetKind() uint32 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *C_ClientLog) GetBehavior() uint32 {
	if m != nil {
		return m.Behavior
	}
	return 0
}

func (m *C_ClientLog) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

// 用户位置 [5003]
type C_UserLocation struct {
	Latitude  uint32 `protobuf:"varint,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude uint32 `protobuf:"varint,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Accuracy  uint32 `protobuf:"varint,3,opt,name=accuracy,proto3" json:"accuracy,omitempty"`
}

func (m *C_UserLocation) Reset()                    { *m = C_UserLocation{} }
func (m *C_UserLocation) String() string            { return proto.CompactTextString(m) }
func (*C_UserLocation) ProtoMessage()               {}
func (*C_UserLocation) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{1} }

func (m *C_UserLocation) GetLatitude() uint32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *C_UserLocation) GetLongitude() uint32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *C_UserLocation) GetAccuracy() uint32 {
	if m != nil {
		return m.Accuracy
	}
	return 0
}

// 分享信息 [5004]
type C_ShareInfo struct {
	Id    uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type  uint32 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Kind  uint32 `protobuf:"varint,3,opt,name=kind,proto3" json:"kind,omitempty"`
	Uid   uint32 `protobuf:"varint,4,opt,name=uid,proto3" json:"uid,omitempty"`
	Param uint32 `protobuf:"varint,5,opt,name=param,proto3" json:"param,omitempty"`
}

func (m *C_ShareInfo) Reset()                    { *m = C_ShareInfo{} }
func (m *C_ShareInfo) String() string            { return proto.CompactTextString(m) }
func (*C_ShareInfo) ProtoMessage()               {}
func (*C_ShareInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{2} }

func (m *C_ShareInfo) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *C_ShareInfo) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *C_ShareInfo) GetKind() uint32 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *C_ShareInfo) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *C_ShareInfo) GetParam() uint32 {
	if m != nil {
		return m.Param
	}
	return 0
}

type S_GetServerTime struct {
	ServerTime int64 `protobuf:"varint,1,opt,name=serverTime,proto3" json:"serverTime,omitempty"`
}

func (m *S_GetServerTime) Reset()                    { *m = S_GetServerTime{} }
func (m *S_GetServerTime) String() string            { return proto.CompactTextString(m) }
func (*S_GetServerTime) ProtoMessage()               {}
func (*S_GetServerTime) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{3} }

func (m *S_GetServerTime) GetServerTime() int64 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

// 登录请求 [6000]
type C_LoginServer struct {
	Account      string       `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	ServerID     uint64       `protobuf:"varint,2,opt,name=serverID,proto3" json:"serverID,omitempty"`
	UserInfo     *UserInfo    `protobuf:"bytes,3,opt,name=userInfo" json:"userInfo,omitempty"`
	Sharing      *SharingInfo `protobuf:"bytes,4,opt,name=sharing" json:"sharing,omitempty"`
	LoginChannel string       `protobuf:"bytes,5,opt,name=loginChannel,proto3" json:"loginChannel,omitempty"`
}

func (m *C_LoginServer) Reset()                    { *m = C_LoginServer{} }
func (m *C_LoginServer) String() string            { return proto.CompactTextString(m) }
func (*C_LoginServer) ProtoMessage()               {}
func (*C_LoginServer) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{4} }

func (m *C_LoginServer) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *C_LoginServer) GetServerID() uint64 {
	if m != nil {
		return m.ServerID
	}
	return 0
}

func (m *C_LoginServer) GetUserInfo() *UserInfo {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

func (m *C_LoginServer) GetSharing() *SharingInfo {
	if m != nil {
		return m.Sharing
	}
	return nil
}

func (m *C_LoginServer) GetLoginChannel() string {
	if m != nil {
		return m.LoginChannel
	}
	return ""
}

type SharingInfo struct {
	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Kind  uint32 `protobuf:"varint,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Uid   uint64 `protobuf:"varint,3,opt,name=uid,proto3" json:"uid,omitempty"`
	Param string `protobuf:"bytes,4,opt,name=param,proto3" json:"param,omitempty"`
}

func (m *SharingInfo) Reset()                    { *m = SharingInfo{} }
func (m *SharingInfo) String() string            { return proto.CompactTextString(m) }
func (*SharingInfo) ProtoMessage()               {}
func (*SharingInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{5} }

func (m *SharingInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SharingInfo) GetKind() uint32 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *SharingInfo) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *SharingInfo) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

// 用户信息
type UserInfo struct {
	AvatarUrl string `protobuf:"bytes,1,opt,name=avatarUrl,proto3" json:"avatarUrl,omitempty"`
	City      string `protobuf:"bytes,2,opt,name=city,proto3" json:"city,omitempty"`
	Country   string `protobuf:"bytes,3,opt,name=country,proto3" json:"country,omitempty"`
	Gender    string `protobuf:"bytes,4,opt,name=gender,proto3" json:"gender,omitempty"`
	Language  string `protobuf:"bytes,5,opt,name=language,proto3" json:"language,omitempty"`
	NickName  string `protobuf:"bytes,6,opt,name=nickName,proto3" json:"nickName,omitempty"`
	Province  string `protobuf:"bytes,7,opt,name=province,proto3" json:"province,omitempty"`
}

func (m *UserInfo) Reset()                    { *m = UserInfo{} }
func (m *UserInfo) String() string            { return proto.CompactTextString(m) }
func (*UserInfo) ProtoMessage()               {}
func (*UserInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{6} }

func (m *UserInfo) GetAvatarUrl() string {
	if m != nil {
		return m.AvatarUrl
	}
	return ""
}

func (m *UserInfo) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *UserInfo) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *UserInfo) GetGender() string {
	if m != nil {
		return m.Gender
	}
	return ""
}

func (m *UserInfo) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *UserInfo) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *UserInfo) GetProvince() string {
	if m != nil {
		return m.Province
	}
	return ""
}

// 登录返回 [6000]
type S_LoginServer struct {
	Uid        uint64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Address    string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Account    string `protobuf:"bytes,3,opt,name=account,proto3" json:"account,omitempty"`
	Sessionkey string `protobuf:"bytes,4,opt,name=sessionkey,proto3" json:"sessionkey,omitempty"`
	Result     uint32 `protobuf:"varint,5,opt,name=result,proto3" json:"result,omitempty"`
	IsNew      uint64 `protobuf:"varint,6,opt,name=isNew,proto3" json:"isNew,omitempty"`
}

func (m *S_LoginServer) Reset()                    { *m = S_LoginServer{} }
func (m *S_LoginServer) String() string            { return proto.CompactTextString(m) }
func (*S_LoginServer) ProtoMessage()               {}
func (*S_LoginServer) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{7} }

func (m *S_LoginServer) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *S_LoginServer) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *S_LoginServer) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *S_LoginServer) GetSessionkey() string {
	if m != nil {
		return m.Sessionkey
	}
	return ""
}

func (m *S_LoginServer) GetResult() uint32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *S_LoginServer) GetIsNew() uint64 {
	if m != nil {
		return m.IsNew
	}
	return 0
}

// 登录重连 [6001]
type C_GameServer struct {
	Uid        uint64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Sessionkey string `protobuf:"bytes,2,opt,name=sessionkey,proto3" json:"sessionkey,omitempty"`
}

func (m *C_GameServer) Reset()                    { *m = C_GameServer{} }
func (m *C_GameServer) String() string            { return proto.CompactTextString(m) }
func (*C_GameServer) ProtoMessage()               {}
func (*C_GameServer) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{8} }

func (m *C_GameServer) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *C_GameServer) GetSessionkey() string {
	if m != nil {
		return m.Sessionkey
	}
	return ""
}

// 登录重连返回 [6001]
type S_GameServer struct {
	Result uint32 `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *S_GameServer) Reset()                    { *m = S_GameServer{} }
func (m *S_GameServer) String() string            { return proto.CompactTextString(m) }
func (*S_GameServer) ProtoMessage()               {}
func (*S_GameServer) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{9} }

func (m *S_GameServer) GetResult() uint32 {
	if m != nil {
		return m.Result
	}
	return 0
}

// 请求玩家信息 [6002]
type C_AccountInfo struct {
	Uid uint64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *C_AccountInfo) Reset()                    { *m = C_AccountInfo{} }
func (m *C_AccountInfo) String() string            { return proto.CompactTextString(m) }
func (*C_AccountInfo) ProtoMessage()               {}
func (*C_AccountInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{10} }

func (m *C_AccountInfo) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

// 返回玩家信息 [6002]
type S_AccountInfo struct {
	Uid      uint64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	NickName string `protobuf:"bytes,2,opt,name=nickName,proto3" json:"nickName,omitempty"`
	Picture  string `protobuf:"bytes,3,opt,name=picture,proto3" json:"picture,omitempty"`
	Location string `protobuf:"bytes,4,opt,name=location,proto3" json:"location,omitempty"`
	Gender   string `protobuf:"bytes,5,opt,name=gender,proto3" json:"gender,omitempty"`
}

func (m *S_AccountInfo) Reset()                    { *m = S_AccountInfo{} }
func (m *S_AccountInfo) String() string            { return proto.CompactTextString(m) }
func (*S_AccountInfo) ProtoMessage()               {}
func (*S_AccountInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{11} }

func (m *S_AccountInfo) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *S_AccountInfo) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *S_AccountInfo) GetPicture() string {
	if m != nil {
		return m.Picture
	}
	return ""
}

func (m *S_AccountInfo) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *S_AccountInfo) GetGender() string {
	if m != nil {
		return m.Gender
	}
	return ""
}

// 玩家角色列表 [6003]
type C_ChrList struct {
	Uid uint64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *C_ChrList) Reset()                    { *m = C_ChrList{} }
func (m *C_ChrList) String() string            { return proto.CompactTextString(m) }
func (*C_ChrList) ProtoMessage()               {}
func (*C_ChrList) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{12} }

func (m *C_ChrList) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

// 返回角色列表 [6003]
type S_ChrList struct {
	Selected   uint32                 `protobuf:"varint,1,opt,name=selected,proto3" json:"selected,omitempty"`
	PlayerList []*S_ChrList_ChrPlayer `protobuf:"bytes,2,rep,name=playerList" json:"playerList,omitempty"`
}

func (m *S_ChrList) Reset()                    { *m = S_ChrList{} }
func (m *S_ChrList) String() string            { return proto.CompactTextString(m) }
func (*S_ChrList) ProtoMessage()               {}
func (*S_ChrList) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{13} }

func (m *S_ChrList) GetSelected() uint32 {
	if m != nil {
		return m.Selected
	}
	return 0
}

func (m *S_ChrList) GetPlayerList() []*S_ChrList_ChrPlayer {
	if m != nil {
		return m.PlayerList
	}
	return nil
}

type S_ChrList_ChrPlayer struct {
	PlayerId uint32 `protobuf:"varint,1,opt,name=playerId,proto3" json:"playerId,omitempty"`
	Sex      uint32 `protobuf:"varint,2,opt,name=sex,proto3" json:"sex,omitempty"`
	Job      uint32 `protobuf:"varint,3,opt,name=job,proto3" json:"job,omitempty"`
	Name_    string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *S_ChrList_ChrPlayer) Reset()                    { *m = S_ChrList_ChrPlayer{} }
func (m *S_ChrList_ChrPlayer) String() string            { return proto.CompactTextString(m) }
func (*S_ChrList_ChrPlayer) ProtoMessage()               {}
func (*S_ChrList_ChrPlayer) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{13, 0} }

func (m *S_ChrList_ChrPlayer) GetPlayerId() uint32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *S_ChrList_ChrPlayer) GetSex() uint32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *S_ChrList_ChrPlayer) GetJob() uint32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *S_ChrList_ChrPlayer) GetName_() string {
	if m != nil {
		return m.Name_
	}
	return ""
}

// 创建新角色 [6005]
type C_NewChr struct {
	Sex   uint32 `protobuf:"varint,1,opt,name=sex,proto3" json:"sex,omitempty"`
	Job   uint32 `protobuf:"varint,2,opt,name=job,proto3" json:"job,omitempty"`
	Name_ uint32 `protobuf:"varint,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *C_NewChr) Reset()                    { *m = C_NewChr{} }
func (m *C_NewChr) String() string            { return proto.CompactTextString(m) }
func (*C_NewChr) ProtoMessage()               {}
func (*C_NewChr) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{14} }

func (m *C_NewChr) GetSex() uint32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *C_NewChr) GetJob() uint32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *C_NewChr) GetName_() uint32 {
	if m != nil {
		return m.Name_
	}
	return 0
}

// 返回创建新角色 [6005]
type S_NewChr struct {
	Result   uint32 `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	PlayerId uint32 `protobuf:"varint,2,opt,name=playerId,proto3" json:"playerId,omitempty"`
}

func (m *S_NewChr) Reset()                    { *m = S_NewChr{} }
func (m *S_NewChr) String() string            { return proto.CompactTextString(m) }
func (*S_NewChr) ProtoMessage()               {}
func (*S_NewChr) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{15} }

func (m *S_NewChr) GetResult() uint32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *S_NewChr) GetPlayerId() uint32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

// 获取随机名称 [6006]
type C_GetName struct {
}

func (m *C_GetName) Reset()                    { *m = C_GetName{} }
func (m *C_GetName) String() string            { return proto.CompactTextString(m) }
func (*C_GetName) ProtoMessage()               {}
func (*C_GetName) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{16} }

// 返回获取随机名称 [6006]
type S_GetName struct {
	RndName string `protobuf:"bytes,1,opt,name=rndName,proto3" json:"rndName,omitempty"`
}

func (m *S_GetName) Reset()                    { *m = S_GetName{} }
func (m *S_GetName) String() string            { return proto.CompactTextString(m) }
func (*S_GetName) ProtoMessage()               {}
func (*S_GetName) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{17} }

func (m *S_GetName) GetRndName() string {
	if m != nil {
		return m.RndName
	}
	return ""
}

// 角色属性 [6007]
type C_PlayerAbility struct {
	PlayerId uint32 `protobuf:"varint,1,opt,name=playerId,proto3" json:"playerId,omitempty"`
}

func (m *C_PlayerAbility) Reset()                    { *m = C_PlayerAbility{} }
func (m *C_PlayerAbility) String() string            { return proto.CompactTextString(m) }
func (*C_PlayerAbility) ProtoMessage()               {}
func (*C_PlayerAbility) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{18} }

func (m *C_PlayerAbility) GetPlayerId() uint32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

type BaseAbility struct {
	Hp     uint64 `protobuf:"varint,1,opt,name=hp,proto3" json:"hp,omitempty"`
	HpMax  uint64 `protobuf:"varint,2,opt,name=hpMax,proto3" json:"hpMax,omitempty"`
	Dc     uint64 `protobuf:"varint,3,opt,name=dc,proto3" json:"dc,omitempty"`
	DcMax  uint64 `protobuf:"varint,4,opt,name=dcMax,proto3" json:"dcMax,omitempty"`
	Mp     uint64 `protobuf:"varint,5,opt,name=mp,proto3" json:"mp,omitempty"`
	MpMax  uint64 `protobuf:"varint,6,opt,name=mpMax,proto3" json:"mpMax,omitempty"`
	Sc     uint64 `protobuf:"varint,7,opt,name=sc,proto3" json:"sc,omitempty"`
	ScMax  uint64 `protobuf:"varint,8,opt,name=scMax,proto3" json:"scMax,omitempty"`
	Ac     uint64 `protobuf:"varint,9,opt,name=ac,proto3" json:"ac,omitempty"`
	AcMax  uint64 `protobuf:"varint,10,opt,name=acMax,proto3" json:"acMax,omitempty"`
	Mac    uint64 `protobuf:"varint,11,opt,name=mac,proto3" json:"mac,omitempty"`
	MacMax uint64 `protobuf:"varint,12,opt,name=macMax,proto3" json:"macMax,omitempty"`
	Hit    uint32 `protobuf:"varint,13,opt,name=hit,proto3" json:"hit,omitempty"`
	Dex    uint32 `protobuf:"varint,14,opt,name=dex,proto3" json:"dex,omitempty"`
	Crit   uint32 `protobuf:"varint,15,opt,name=crit,proto3" json:"crit,omitempty"`
}

func (m *BaseAbility) Reset()                    { *m = BaseAbility{} }
func (m *BaseAbility) String() string            { return proto.CompactTextString(m) }
func (*BaseAbility) ProtoMessage()               {}
func (*BaseAbility) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{19} }

func (m *BaseAbility) GetHp() uint64 {
	if m != nil {
		return m.Hp
	}
	return 0
}

func (m *BaseAbility) GetHpMax() uint64 {
	if m != nil {
		return m.HpMax
	}
	return 0
}

func (m *BaseAbility) GetDc() uint64 {
	if m != nil {
		return m.Dc
	}
	return 0
}

func (m *BaseAbility) GetDcMax() uint64 {
	if m != nil {
		return m.DcMax
	}
	return 0
}

func (m *BaseAbility) GetMp() uint64 {
	if m != nil {
		return m.Mp
	}
	return 0
}

func (m *BaseAbility) GetMpMax() uint64 {
	if m != nil {
		return m.MpMax
	}
	return 0
}

func (m *BaseAbility) GetSc() uint64 {
	if m != nil {
		return m.Sc
	}
	return 0
}

func (m *BaseAbility) GetScMax() uint64 {
	if m != nil {
		return m.ScMax
	}
	return 0
}

func (m *BaseAbility) GetAc() uint64 {
	if m != nil {
		return m.Ac
	}
	return 0
}

func (m *BaseAbility) GetAcMax() uint64 {
	if m != nil {
		return m.AcMax
	}
	return 0
}

func (m *BaseAbility) GetMac() uint64 {
	if m != nil {
		return m.Mac
	}
	return 0
}

func (m *BaseAbility) GetMacMax() uint64 {
	if m != nil {
		return m.MacMax
	}
	return 0
}

func (m *BaseAbility) GetHit() uint32 {
	if m != nil {
		return m.Hit
	}
	return 0
}

func (m *BaseAbility) GetDex() uint32 {
	if m != nil {
		return m.Dex
	}
	return 0
}

func (m *BaseAbility) GetCrit() uint32 {
	if m != nil {
		return m.Crit
	}
	return 0
}

// 返回角色属性 [6007]
type S_PlayerAbility struct {
	PlayerId uint32       `protobuf:"varint,1,opt,name=playerId,proto3" json:"playerId,omitempty"`
	Sex      uint32       `protobuf:"varint,2,opt,name=sex,proto3" json:"sex,omitempty"`
	Job      uint32       `protobuf:"varint,3,opt,name=job,proto3" json:"job,omitempty"`
	Level    uint32       `protobuf:"varint,4,opt,name=level,proto3" json:"level,omitempty"`
	ChrName  string       `protobuf:"bytes,5,opt,name=chrName,proto3" json:"chrName,omitempty"`
	Ability  *BaseAbility `protobuf:"bytes,6,opt,name=ability" json:"ability,omitempty"`
	Exp      uint64       `protobuf:"varint,7,opt,name=exp,proto3" json:"exp,omitempty"`
	ExpMax   uint64       `protobuf:"varint,8,opt,name=expMax,proto3" json:"expMax,omitempty"`
	Gold     uint64       `protobuf:"varint,9,opt,name=gold,proto3" json:"gold,omitempty"`
	Yb       uint64       `protobuf:"varint,10,opt,name=yb,proto3" json:"yb,omitempty"`
	Cpv      uint64       `protobuf:"varint,11,opt,name=cpv,proto3" json:"cpv,omitempty"`
	MapId    uint32       `protobuf:"varint,12,opt,name=mapId,proto3" json:"mapId,omitempty"`
}

func (m *S_PlayerAbility) Reset()                    { *m = S_PlayerAbility{} }
func (m *S_PlayerAbility) String() string            { return proto.CompactTextString(m) }
func (*S_PlayerAbility) ProtoMessage()               {}
func (*S_PlayerAbility) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{20} }

func (m *S_PlayerAbility) GetPlayerId() uint32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *S_PlayerAbility) GetSex() uint32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *S_PlayerAbility) GetJob() uint32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *S_PlayerAbility) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *S_PlayerAbility) GetChrName() string {
	if m != nil {
		return m.ChrName
	}
	return ""
}

func (m *S_PlayerAbility) GetAbility() *BaseAbility {
	if m != nil {
		return m.Ability
	}
	return nil
}

func (m *S_PlayerAbility) GetExp() uint64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *S_PlayerAbility) GetExpMax() uint64 {
	if m != nil {
		return m.ExpMax
	}
	return 0
}

func (m *S_PlayerAbility) GetGold() uint64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *S_PlayerAbility) GetYb() uint64 {
	if m != nil {
		return m.Yb
	}
	return 0
}

func (m *S_PlayerAbility) GetCpv() uint64 {
	if m != nil {
		return m.Cpv
	}
	return 0
}

func (m *S_PlayerAbility) GetMapId() uint32 {
	if m != nil {
		return m.MapId
	}
	return 0
}

// 请求地图信息 [6008]
type C_ChangeMap struct {
	MapId uint32 `protobuf:"varint,1,opt,name=mapId,proto3" json:"mapId,omitempty"`
}

func (m *C_ChangeMap) Reset()                    { *m = C_ChangeMap{} }
func (m *C_ChangeMap) String() string            { return proto.CompactTextString(m) }
func (*C_ChangeMap) ProtoMessage()               {}
func (*C_ChangeMap) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{21} }

func (m *C_ChangeMap) GetMapId() uint32 {
	if m != nil {
		return m.MapId
	}
	return 0
}

// 返回请求地图信息 [6008]
type S_ChangeMap struct {
	MapId         uint32 `protobuf:"varint,1,opt,name=mapId,proto3" json:"mapId,omitempty"`
	MapName       string `protobuf:"bytes,2,opt,name=mapName,proto3" json:"mapName,omitempty"`
	AddExp        uint32 `protobuf:"varint,3,opt,name=addExp,proto3" json:"addExp,omitempty"`
	AddGold       uint32 `protobuf:"varint,4,opt,name=addGold,proto3" json:"addGold,omitempty"`
	AddInterval   uint32 `protobuf:"varint,5,opt,name=addInterval,proto3" json:"addInterval,omitempty"`
	UnlockLv      uint32 `protobuf:"varint,6,opt,name=unlockLv,proto3" json:"unlockLv,omitempty"`
	MapAttackMode uint32 `protobuf:"varint,7,opt,name=mapAttackMode,proto3" json:"mapAttackMode,omitempty"`
	MapBossId     uint32 `protobuf:"varint,8,opt,name=mapBossId,proto3" json:"mapBossId,omitempty"`
	MapDepth      uint32 `protobuf:"varint,9,opt,name=mapDepth,proto3" json:"mapDepth,omitempty"`
	MapKill       uint32 `protobuf:"varint,10,opt,name=mapKill,proto3" json:"mapKill,omitempty"`
	MapIsKillBoss uint32 `protobuf:"varint,11,opt,name=mapIsKillBoss,proto3" json:"mapIsKillBoss,omitempty"`
	ShowX         uint32 `protobuf:"varint,12,opt,name=showX,proto3" json:"showX,omitempty"`
	ShowY         uint32 `protobuf:"varint,13,opt,name=showY,proto3" json:"showY,omitempty"`
}

func (m *S_ChangeMap) Reset()                    { *m = S_ChangeMap{} }
func (m *S_ChangeMap) String() string            { return proto.CompactTextString(m) }
func (*S_ChangeMap) ProtoMessage()               {}
func (*S_ChangeMap) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{22} }

func (m *S_ChangeMap) GetMapId() uint32 {
	if m != nil {
		return m.MapId
	}
	return 0
}

func (m *S_ChangeMap) GetMapName() string {
	if m != nil {
		return m.MapName
	}
	return ""
}

func (m *S_ChangeMap) GetAddExp() uint32 {
	if m != nil {
		return m.AddExp
	}
	return 0
}

func (m *S_ChangeMap) GetAddGold() uint32 {
	if m != nil {
		return m.AddGold
	}
	return 0
}

func (m *S_ChangeMap) GetAddInterval() uint32 {
	if m != nil {
		return m.AddInterval
	}
	return 0
}

func (m *S_ChangeMap) GetUnlockLv() uint32 {
	if m != nil {
		return m.UnlockLv
	}
	return 0
}

func (m *S_ChangeMap) GetMapAttackMode() uint32 {
	if m != nil {
		return m.MapAttackMode
	}
	return 0
}

func (m *S_ChangeMap) GetMapBossId() uint32 {
	if m != nil {
		return m.MapBossId
	}
	return 0
}

func (m *S_ChangeMap) GetMapDepth() uint32 {
	if m != nil {
		return m.MapDepth
	}
	return 0
}

func (m *S_ChangeMap) GetMapKill() uint32 {
	if m != nil {
		return m.MapKill
	}
	return 0
}

func (m *S_ChangeMap) GetMapIsKillBoss() uint32 {
	if m != nil {
		return m.MapIsKillBoss
	}
	return 0
}

func (m *S_ChangeMap) GetShowX() uint32 {
	if m != nil {
		return m.ShowX
	}
	return 0
}

func (m *S_ChangeMap) GetShowY() uint32 {
	if m != nil {
		return m.ShowY
	}
	return 0
}

// 请求包裹列表 [6009]
type C_GetBagItems struct {
	PlayerId uint32 `protobuf:"varint,1,opt,name=playerId,proto3" json:"playerId,omitempty"`
}

func (m *C_GetBagItems) Reset()                    { *m = C_GetBagItems{} }
func (m *C_GetBagItems) String() string            { return proto.CompactTextString(m) }
func (*C_GetBagItems) ProtoMessage()               {}
func (*C_GetBagItems) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{23} }

func (m *C_GetBagItems) GetPlayerId() uint32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

// 包裹物品
type BagItem struct {
	ItemId    uint32 `protobuf:"varint,1,opt,name=itemId,proto3" json:"itemId,omitempty"`
	BagSlotId uint32 `protobuf:"varint,2,opt,name=bagSlotId,proto3" json:"bagSlotId,omitempty"`
	CurCnt    string `protobuf:"bytes,3,opt,name=curCnt,proto3" json:"curCnt,omitempty"`
}

func (m *BagItem) Reset()                    { *m = BagItem{} }
func (m *BagItem) String() string            { return proto.CompactTextString(m) }
func (*BagItem) ProtoMessage()               {}
func (*BagItem) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{24} }

func (m *BagItem) GetItemId() uint32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *BagItem) GetBagSlotId() uint32 {
	if m != nil {
		return m.BagSlotId
	}
	return 0
}

func (m *BagItem) GetCurCnt() string {
	if m != nil {
		return m.CurCnt
	}
	return ""
}

// 返回请求包裹列表 [6009]
type S_GetBagItems struct {
	BagSize    uint32     `protobuf:"varint,1,opt,name=bagSize,proto3" json:"bagSize,omitempty"`
	MaxBagSize uint32     `protobuf:"varint,2,opt,name=maxBagSize,proto3" json:"maxBagSize,omitempty"`
	ItemList   []*BagItem `protobuf:"bytes,3,rep,name=itemList" json:"itemList,omitempty"`
}

func (m *S_GetBagItems) Reset()                    { *m = S_GetBagItems{} }
func (m *S_GetBagItems) String() string            { return proto.CompactTextString(m) }
func (*S_GetBagItems) ProtoMessage()               {}
func (*S_GetBagItems) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{25} }

func (m *S_GetBagItems) GetBagSize() uint32 {
	if m != nil {
		return m.BagSize
	}
	return 0
}

func (m *S_GetBagItems) GetMaxBagSize() uint32 {
	if m != nil {
		return m.MaxBagSize
	}
	return 0
}

func (m *S_GetBagItems) GetItemList() []*BagItem {
	if m != nil {
		return m.ItemList
	}
	return nil
}

// 请求装备列表 [6010]
type C_GetEquips struct {
	PlayerId uint32 `protobuf:"varint,1,opt,name=playerId,proto3" json:"playerId,omitempty"`
}

func (m *C_GetEquips) Reset()                    { *m = C_GetEquips{} }
func (m *C_GetEquips) String() string            { return proto.CompactTextString(m) }
func (*C_GetEquips) ProtoMessage()               {}
func (*C_GetEquips) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{26} }

func (m *C_GetEquips) GetPlayerId() uint32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

type EquipItem struct {
	Id      uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ItemId  uint32 `protobuf:"varint,2,opt,name=itemId,proto3" json:"itemId,omitempty"`
	SavePos uint32 `protobuf:"varint,3,opt,name=savePos,proto3" json:"savePos,omitempty"`
	Luck    uint32 `protobuf:"varint,4,opt,name=luck,proto3" json:"luck,omitempty"`
	MagicId uint32 `protobuf:"varint,5,opt,name=magicId,proto3" json:"magicId,omitempty"`
}

func (m *EquipItem) Reset()                    { *m = EquipItem{} }
func (m *EquipItem) String() string            { return proto.CompactTextString(m) }
func (*EquipItem) ProtoMessage()               {}
func (*EquipItem) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{27} }

func (m *EquipItem) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EquipItem) GetItemId() uint32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *EquipItem) GetSavePos() uint32 {
	if m != nil {
		return m.SavePos
	}
	return 0
}

func (m *EquipItem) GetLuck() uint32 {
	if m != nil {
		return m.Luck
	}
	return 0
}

func (m *EquipItem) GetMagicId() uint32 {
	if m != nil {
		return m.MagicId
	}
	return 0
}

// 返回请求装备列表 [6010]
type S_GetEquips struct {
	IsHero    uint32       `protobuf:"varint,1,opt,name=isHero,proto3" json:"isHero,omitempty"`
	HeroType  uint32       `protobuf:"varint,2,opt,name=heroType,proto3" json:"heroType,omitempty"`
	EquipList []*EquipItem `protobuf:"bytes,3,rep,name=equipList" json:"equipList,omitempty"`
}

func (m *S_GetEquips) Reset()                    { *m = S_GetEquips{} }
func (m *S_GetEquips) String() string            { return proto.CompactTextString(m) }
func (*S_GetEquips) ProtoMessage()               {}
func (*S_GetEquips) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{28} }

func (m *S_GetEquips) GetIsHero() uint32 {
	if m != nil {
		return m.IsHero
	}
	return 0
}

func (m *S_GetEquips) GetHeroType() uint32 {
	if m != nil {
		return m.HeroType
	}
	return 0
}

func (m *S_GetEquips) GetEquipList() []*EquipItem {
	if m != nil {
		return m.EquipList
	}
	return nil
}

// 请求技能列表 [6011]
type C_GetSkills struct {
	PlayerId uint32 `protobuf:"varint,1,opt,name=playerId,proto3" json:"playerId,omitempty"`
}

func (m *C_GetSkills) Reset()                    { *m = C_GetSkills{} }
func (m *C_GetSkills) String() string            { return proto.CompactTextString(m) }
func (*C_GetSkills) ProtoMessage()               {}
func (*C_GetSkills) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{29} }

func (m *C_GetSkills) GetPlayerId() uint32 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

// 技能
type SkillItem struct {
	Id        uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	SavePos   uint32 `protobuf:"varint,2,opt,name=savePos,proto3" json:"savePos,omitempty"`
	IsLevelUp uint32 `protobuf:"varint,3,opt,name=isLevelUp,proto3" json:"isLevelUp,omitempty"`
}

func (m *SkillItem) Reset()                    { *m = SkillItem{} }
func (m *SkillItem) String() string            { return proto.CompactTextString(m) }
func (*SkillItem) ProtoMessage()               {}
func (*SkillItem) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{30} }

func (m *SkillItem) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SkillItem) GetSavePos() uint32 {
	if m != nil {
		return m.SavePos
	}
	return 0
}

func (m *SkillItem) GetIsLevelUp() uint32 {
	if m != nil {
		return m.IsLevelUp
	}
	return 0
}

// 返回请求技能列表 [6011]
type S_GetSkills struct {
	IsHero    uint32       `protobuf:"varint,1,opt,name=isHero,proto3" json:"isHero,omitempty"`
	HeroType  uint32       `protobuf:"varint,2,opt,name=heroType,proto3" json:"heroType,omitempty"`
	SkillList []*SkillItem `protobuf:"bytes,3,rep,name=skillList" json:"skillList,omitempty"`
}

func (m *S_GetSkills) Reset()                    { *m = S_GetSkills{} }
func (m *S_GetSkills) String() string            { return proto.CompactTextString(m) }
func (*S_GetSkills) ProtoMessage()               {}
func (*S_GetSkills) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{31} }

func (m *S_GetSkills) GetIsHero() uint32 {
	if m != nil {
		return m.IsHero
	}
	return 0
}

func (m *S_GetSkills) GetHeroType() uint32 {
	if m != nil {
		return m.HeroType
	}
	return 0
}

func (m *S_GetSkills) GetSkillList() []*SkillItem {
	if m != nil {
		return m.SkillList
	}
	return nil
}

func init() {
	proto.RegisterType((*C_ClientLog)(nil), "protoMsg.C_ClientLog")
	proto.RegisterType((*C_UserLocation)(nil), "protoMsg.C_UserLocation")
	proto.RegisterType((*C_ShareInfo)(nil), "protoMsg.C_ShareInfo")
	proto.RegisterType((*S_GetServerTime)(nil), "protoMsg.S_GetServerTime")
	proto.RegisterType((*C_LoginServer)(nil), "protoMsg.C_LoginServer")
	proto.RegisterType((*SharingInfo)(nil), "protoMsg.SharingInfo")
	proto.RegisterType((*UserInfo)(nil), "protoMsg.UserInfo")
	proto.RegisterType((*S_LoginServer)(nil), "protoMsg.S_LoginServer")
	proto.RegisterType((*C_GameServer)(nil), "protoMsg.C_GameServer")
	proto.RegisterType((*S_GameServer)(nil), "protoMsg.S_GameServer")
	proto.RegisterType((*C_AccountInfo)(nil), "protoMsg.C_AccountInfo")
	proto.RegisterType((*S_AccountInfo)(nil), "protoMsg.S_AccountInfo")
	proto.RegisterType((*C_ChrList)(nil), "protoMsg.C_ChrList")
	proto.RegisterType((*S_ChrList)(nil), "protoMsg.S_ChrList")
	proto.RegisterType((*S_ChrList_ChrPlayer)(nil), "protoMsg.S_ChrList.ChrPlayer")
	proto.RegisterType((*C_NewChr)(nil), "protoMsg.C_NewChr")
	proto.RegisterType((*S_NewChr)(nil), "protoMsg.S_NewChr")
	proto.RegisterType((*C_GetName)(nil), "protoMsg.C_GetName")
	proto.RegisterType((*S_GetName)(nil), "protoMsg.S_GetName")
	proto.RegisterType((*C_PlayerAbility)(nil), "protoMsg.C_PlayerAbility")
	proto.RegisterType((*BaseAbility)(nil), "protoMsg.BaseAbility")
	proto.RegisterType((*S_PlayerAbility)(nil), "protoMsg.S_PlayerAbility")
	proto.RegisterType((*C_ChangeMap)(nil), "protoMsg.C_ChangeMap")
	proto.RegisterType((*S_ChangeMap)(nil), "protoMsg.S_ChangeMap")
	proto.RegisterType((*C_GetBagItems)(nil), "protoMsg.C_GetBagItems")
	proto.RegisterType((*BagItem)(nil), "protoMsg.BagItem")
	proto.RegisterType((*S_GetBagItems)(nil), "protoMsg.S_GetBagItems")
	proto.RegisterType((*C_GetEquips)(nil), "protoMsg.C_GetEquips")
	proto.RegisterType((*EquipItem)(nil), "protoMsg.EquipItem")
	proto.RegisterType((*S_GetEquips)(nil), "protoMsg.S_GetEquips")
	proto.RegisterType((*C_GetSkills)(nil), "protoMsg.C_GetSkills")
	proto.RegisterType((*SkillItem)(nil), "protoMsg.SkillItem")
	proto.RegisterType((*S_GetSkills)(nil), "protoMsg.S_GetSkills")
	proto.RegisterEnum("protoMsg.C_CMD", C_CMD_name, C_CMD_value)
	proto.RegisterEnum("protoMsg.S_CMD", S_CMD_name, S_CMD_value)
}
func (m *C_ClientLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ClientLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Kind))
	}
	if m.Behavior != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Behavior))
	}
	if len(m.Param) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Param)))
		i += copy(dAtA[i:], m.Param)
	}
	return i, nil
}

func (m *C_UserLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_UserLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Latitude != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Longitude))
	}
	if m.Accuracy != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Accuracy))
	}
	return i, nil
}

func (m *C_ShareInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ShareInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Type))
	}
	if m.Kind != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Kind))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	}
	if m.Param != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Param))
	}
	return i, nil
}

func (m *S_GetServerTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_GetServerTime) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.ServerTime))
	}
	return i, nil
}

func (m *C_LoginServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_LoginServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Account) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Account)))
		i += copy(dAtA[i:], m.Account)
	}
	if m.ServerID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.ServerID))
	}
	if m.UserInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.UserInfo.Size()))
		n1, err := m.UserInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Sharing != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Sharing.Size()))
		n2, err := m.Sharing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.LoginChannel) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.LoginChannel)))
		i += copy(dAtA[i:], m.LoginChannel)
	}
	return i, nil
}

func (m *SharingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SharingInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Kind))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	}
	if len(m.Param) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Param)))
		i += copy(dAtA[i:], m.Param)
	}
	return i, nil
}

func (m *UserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AvatarUrl) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.AvatarUrl)))
		i += copy(dAtA[i:], m.AvatarUrl)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if len(m.Gender) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Gender)))
		i += copy(dAtA[i:], m.Gender)
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if len(m.NickName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if len(m.Province) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Province)))
		i += copy(dAtA[i:], m.Province)
	}
	return i, nil
}

func (m *S_LoginServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_LoginServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Account) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Account)))
		i += copy(dAtA[i:], m.Account)
	}
	if len(m.Sessionkey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Sessionkey)))
		i += copy(dAtA[i:], m.Sessionkey)
	}
	if m.Result != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Result))
	}
	if m.IsNew != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.IsNew))
	}
	return i, nil
}

func (m *C_GameServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_GameServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	}
	if len(m.Sessionkey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Sessionkey)))
		i += copy(dAtA[i:], m.Sessionkey)
	}
	return i, nil
}

func (m *S_GameServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_GameServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *C_AccountInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_AccountInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *S_AccountInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_AccountInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	}
	if len(m.NickName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if len(m.Picture) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Picture)))
		i += copy(dAtA[i:], m.Picture)
	}
	if len(m.Location) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Location)))
		i += copy(dAtA[i:], m.Location)
	}
	if len(m.Gender) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Gender)))
		i += copy(dAtA[i:], m.Gender)
	}
	return i, nil
}

func (m *C_ChrList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ChrList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *S_ChrList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_ChrList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Selected != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Selected))
	}
	if len(m.PlayerList) > 0 {
		for _, msg := range m.PlayerList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *S_ChrList_ChrPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_ChrList_ChrPlayer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlayerId))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Sex))
	}
	if m.Job != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Job))
	}
	if len(m.Name_) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Name_)))
		i += copy(dAtA[i:], m.Name_)
	}
	return i, nil
}

func (m *C_NewChr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_NewChr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Sex))
	}
	if m.Job != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Job))
	}
	if m.Name_ != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Name_))
	}
	return i, nil
}

func (m *S_NewChr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_NewChr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Result))
	}
	if m.PlayerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlayerId))
	}
	return i, nil
}

func (m *C_GetName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_GetName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *S_GetName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_GetName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RndName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.RndName)))
		i += copy(dAtA[i:], m.RndName)
	}
	return i, nil
}

func (m *C_PlayerAbility) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_PlayerAbility) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlayerId))
	}
	return i, nil
}

func (m *BaseAbility) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseAbility) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Hp))
	}
	if m.HpMax != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.HpMax))
	}
	if m.Dc != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Dc))
	}
	if m.DcMax != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.DcMax))
	}
	if m.Mp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Mp))
	}
	if m.MpMax != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MpMax))
	}
	if m.Sc != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Sc))
	}
	if m.ScMax != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.ScMax))
	}
	if m.Ac != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Ac))
	}
	if m.AcMax != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.AcMax))
	}
	if m.Mac != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Mac))
	}
	if m.MacMax != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MacMax))
	}
	if m.Hit != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Hit))
	}
	if m.Dex != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Dex))
	}
	if m.Crit != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Crit))
	}
	return i, nil
}

func (m *S_PlayerAbility) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_PlayerAbility) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlayerId))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Sex))
	}
	if m.Job != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Job))
	}
	if m.Level != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Level))
	}
	if len(m.ChrName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.ChrName)))
		i += copy(dAtA[i:], m.ChrName)
	}
	if m.Ability != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Ability.Size()))
		n3, err := m.Ability.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Exp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Exp))
	}
	if m.ExpMax != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.ExpMax))
	}
	if m.Gold != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Gold))
	}
	if m.Yb != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Yb))
	}
	if m.Cpv != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Cpv))
	}
	if m.MapId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MapId))
	}
	return i, nil
}

func (m *C_ChangeMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_ChangeMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MapId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MapId))
	}
	return i, nil
}

func (m *S_ChangeMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_ChangeMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MapId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MapId))
	}
	if len(m.MapName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.MapName)))
		i += copy(dAtA[i:], m.MapName)
	}
	if m.AddExp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.AddExp))
	}
	if m.AddGold != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.AddGold))
	}
	if m.AddInterval != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.AddInterval))
	}
	if m.UnlockLv != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.UnlockLv))
	}
	if m.MapAttackMode != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MapAttackMode))
	}
	if m.MapBossId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MapBossId))
	}
	if m.MapDepth != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MapDepth))
	}
	if m.MapKill != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MapKill))
	}
	if m.MapIsKillBoss != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MapIsKillBoss))
	}
	if m.ShowX != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.ShowX))
	}
	if m.ShowY != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.ShowY))
	}
	return i, nil
}

func (m *C_GetBagItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_GetBagItems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlayerId))
	}
	return i, nil
}

func (m *BagItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BagItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.ItemId))
	}
	if m.BagSlotId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.BagSlotId))
	}
	if len(m.CurCnt) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.CurCnt)))
		i += copy(dAtA[i:], m.CurCnt)
	}
	return i, nil
}

func (m *S_GetBagItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_GetBagItems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BagSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.BagSize))
	}
	if m.MaxBagSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MaxBagSize))
	}
	if len(m.ItemList) > 0 {
		for _, msg := range m.ItemList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *C_GetEquips) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_GetEquips) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlayerId))
	}
	return i, nil
}

func (m *EquipItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquipItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.ItemId))
	}
	if m.SavePos != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SavePos))
	}
	if m.Luck != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Luck))
	}
	if m.MagicId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MagicId))
	}
	return i, nil
}

func (m *S_GetEquips) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_GetEquips) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsHero != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.IsHero))
	}
	if m.HeroType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.HeroType))
	}
	if len(m.EquipList) > 0 {
		for _, msg := range m.EquipList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *C_GetSkills) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C_GetSkills) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlayerId))
	}
	return i, nil
}

func (m *SkillItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
	}
	if m.SavePos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SavePos))
	}
	if m.IsLevelUp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.IsLevelUp))
	}
	return i, nil
}

func (m *S_GetSkills) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S_GetSkills) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsHero != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.IsHero))
	}
	if m.HeroType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.HeroType))
	}
	if len(m.SkillList) > 0 {
		for _, msg := range m.SkillList {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Game(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Game(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGame(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *C_ClientLog) Name() string {
	return "C_ClientLog"
}

func (m *C_UserLocation) Name() string {
	return "C_UserLocation"
}

func (m *C_ShareInfo) Name() string {
	return "C_ShareInfo"
}

func (m *S_GetServerTime) Name() string {
	return "S_GetServerTime"
}

func (m *C_LoginServer) Name() string {
	return "C_LoginServer"
}

func (m *SharingInfo) Name() string {
	return "SharingInfo"
}

func (m *UserInfo) Name() string {
	return "UserInfo"
}

func (m *S_LoginServer) Name() string {
	return "S_LoginServer"
}

func (m *C_GameServer) Name() string {
	return "C_GameServer"
}

func (m *S_GameServer) Name() string {
	return "S_GameServer"
}

func (m *C_AccountInfo) Name() string {
	return "C_AccountInfo"
}

func (m *S_AccountInfo) Name() string {
	return "S_AccountInfo"
}

func (m *C_ChrList) Name() string {
	return "C_ChrList"
}

func (m *S_ChrList) Name() string {
	return "S_ChrList"
}

func (m *S_ChrList_ChrPlayer) Name() string {
	return "ChrPlayer"
}

func (m *C_NewChr) Name() string {
	return "C_NewChr"
}

func (m *S_NewChr) Name() string {
	return "S_NewChr"
}

func (m *C_GetName) Name() string {
	return "C_GetName"
}

func (m *S_GetName) Name() string {
	return "S_GetName"
}

func (m *C_PlayerAbility) Name() string {
	return "C_PlayerAbility"
}

func (m *BaseAbility) Name() string {
	return "BaseAbility"
}

func (m *S_PlayerAbility) Name() string {
	return "S_PlayerAbility"
}

func (m *C_ChangeMap) Name() string {
	return "C_ChangeMap"
}

func (m *S_ChangeMap) Name() string {
	return "S_ChangeMap"
}

func (m *C_GetBagItems) Name() string {
	return "C_GetBagItems"
}

func (m *BagItem) Name() string {
	return "BagItem"
}

func (m *S_GetBagItems) Name() string {
	return "S_GetBagItems"
}

func (m *C_GetEquips) Name() string {
	return "C_GetEquips"
}

func (m *EquipItem) Name() string {
	return "EquipItem"
}

func (m *S_GetEquips) Name() string {
	return "S_GetEquips"
}

func (m *C_GetSkills) Name() string {
	return "C_GetSkills"
}

func (m *SkillItem) Name() string {
	return "SkillItem"
}

func (m *S_GetSkills) Name() string {
	return "S_GetSkills"
}

func (m *C_ClientLog) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovGame(uint64(m.Kind))
	}
	if m.Behavior != 0 {
		n += 1 + sovGame(uint64(m.Behavior))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *C_UserLocation) Size() (n int) {
	var l int
	_ = l
	if m.Latitude != 0 {
		n += 1 + sovGame(uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		n += 1 + sovGame(uint64(m.Longitude))
	}
	if m.Accuracy != 0 {
		n += 1 + sovGame(uint64(m.Accuracy))
	}
	return n
}

func (m *C_ShareInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovGame(uint64(m.Type))
	}
	if m.Kind != 0 {
		n += 1 + sovGame(uint64(m.Kind))
	}
	if m.Uid != 0 {
		n += 1 + sovGame(uint64(m.Uid))
	}
	if m.Param != 0 {
		n += 1 + sovGame(uint64(m.Param))
	}
	return n
}

func (m *S_GetServerTime) Size() (n int) {
	var l int
	_ = l
	if m.ServerTime != 0 {
		n += 1 + sovGame(uint64(m.ServerTime))
	}
	return n
}

func (m *C_LoginServer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.ServerID != 0 {
		n += 1 + sovGame(uint64(m.ServerID))
	}
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Sharing != nil {
		l = m.Sharing.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.LoginChannel)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *SharingInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovGame(uint64(m.Kind))
	}
	if m.Uid != 0 {
		n += 1 + sovGame(uint64(m.Uid))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *UserInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.AvatarUrl)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Gender)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Province)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *S_LoginServer) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGame(uint64(m.Uid))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Sessionkey)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovGame(uint64(m.Result))
	}
	if m.IsNew != 0 {
		n += 1 + sovGame(uint64(m.IsNew))
	}
	return n
}

func (m *C_GameServer) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGame(uint64(m.Uid))
	}
	l = len(m.Sessionkey)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *S_GameServer) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovGame(uint64(m.Result))
	}
	return n
}

func (m *C_AccountInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGame(uint64(m.Uid))
	}
	return n
}

func (m *S_AccountInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGame(uint64(m.Uid))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Picture)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Gender)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *C_ChrList) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGame(uint64(m.Uid))
	}
	return n
}

func (m *S_ChrList) Size() (n int) {
	var l int
	_ = l
	if m.Selected != 0 {
		n += 1 + sovGame(uint64(m.Selected))
	}
	if len(m.PlayerList) > 0 {
		for _, e := range m.PlayerList {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *S_ChrList_ChrPlayer) Size() (n int) {
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovGame(uint64(m.PlayerId))
	}
	if m.Sex != 0 {
		n += 1 + sovGame(uint64(m.Sex))
	}
	if m.Job != 0 {
		n += 1 + sovGame(uint64(m.Job))
	}
	l = len(m.Name_)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *C_NewChr) Size() (n int) {
	var l int
	_ = l
	if m.Sex != 0 {
		n += 1 + sovGame(uint64(m.Sex))
	}
	if m.Job != 0 {
		n += 1 + sovGame(uint64(m.Job))
	}
	if m.Name_ != 0 {
		n += 1 + sovGame(uint64(m.Name_))
	}
	return n
}

func (m *S_NewChr) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovGame(uint64(m.Result))
	}
	if m.PlayerId != 0 {
		n += 1 + sovGame(uint64(m.PlayerId))
	}
	return n
}

func (m *C_GetName) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *S_GetName) Size() (n int) {
	var l int
	_ = l
	l = len(m.RndName)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *C_PlayerAbility) Size() (n int) {
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovGame(uint64(m.PlayerId))
	}
	return n
}

func (m *BaseAbility) Size() (n int) {
	var l int
	_ = l
	if m.Hp != 0 {
		n += 1 + sovGame(uint64(m.Hp))
	}
	if m.HpMax != 0 {
		n += 1 + sovGame(uint64(m.HpMax))
	}
	if m.Dc != 0 {
		n += 1 + sovGame(uint64(m.Dc))
	}
	if m.DcMax != 0 {
		n += 1 + sovGame(uint64(m.DcMax))
	}
	if m.Mp != 0 {
		n += 1 + sovGame(uint64(m.Mp))
	}
	if m.MpMax != 0 {
		n += 1 + sovGame(uint64(m.MpMax))
	}
	if m.Sc != 0 {
		n += 1 + sovGame(uint64(m.Sc))
	}
	if m.ScMax != 0 {
		n += 1 + sovGame(uint64(m.ScMax))
	}
	if m.Ac != 0 {
		n += 1 + sovGame(uint64(m.Ac))
	}
	if m.AcMax != 0 {
		n += 1 + sovGame(uint64(m.AcMax))
	}
	if m.Mac != 0 {
		n += 1 + sovGame(uint64(m.Mac))
	}
	if m.MacMax != 0 {
		n += 1 + sovGame(uint64(m.MacMax))
	}
	if m.Hit != 0 {
		n += 1 + sovGame(uint64(m.Hit))
	}
	if m.Dex != 0 {
		n += 1 + sovGame(uint64(m.Dex))
	}
	if m.Crit != 0 {
		n += 1 + sovGame(uint64(m.Crit))
	}
	return n
}

func (m *S_PlayerAbility) Size() (n int) {
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovGame(uint64(m.PlayerId))
	}
	if m.Sex != 0 {
		n += 1 + sovGame(uint64(m.Sex))
	}
	if m.Job != 0 {
		n += 1 + sovGame(uint64(m.Job))
	}
	if m.Level != 0 {
		n += 1 + sovGame(uint64(m.Level))
	}
	l = len(m.ChrName)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Ability != nil {
		l = m.Ability.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Exp != 0 {
		n += 1 + sovGame(uint64(m.Exp))
	}
	if m.ExpMax != 0 {
		n += 1 + sovGame(uint64(m.ExpMax))
	}
	if m.Gold != 0 {
		n += 1 + sovGame(uint64(m.Gold))
	}
	if m.Yb != 0 {
		n += 1 + sovGame(uint64(m.Yb))
	}
	if m.Cpv != 0 {
		n += 1 + sovGame(uint64(m.Cpv))
	}
	if m.MapId != 0 {
		n += 1 + sovGame(uint64(m.MapId))
	}
	return n
}

func (m *C_ChangeMap) Size() (n int) {
	var l int
	_ = l
	if m.MapId != 0 {
		n += 1 + sovGame(uint64(m.MapId))
	}
	return n
}

func (m *S_ChangeMap) Size() (n int) {
	var l int
	_ = l
	if m.MapId != 0 {
		n += 1 + sovGame(uint64(m.MapId))
	}
	l = len(m.MapName)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.AddExp != 0 {
		n += 1 + sovGame(uint64(m.AddExp))
	}
	if m.AddGold != 0 {
		n += 1 + sovGame(uint64(m.AddGold))
	}
	if m.AddInterval != 0 {
		n += 1 + sovGame(uint64(m.AddInterval))
	}
	if m.UnlockLv != 0 {
		n += 1 + sovGame(uint64(m.UnlockLv))
	}
	if m.MapAttackMode != 0 {
		n += 1 + sovGame(uint64(m.MapAttackMode))
	}
	if m.MapBossId != 0 {
		n += 1 + sovGame(uint64(m.MapBossId))
	}
	if m.MapDepth != 0 {
		n += 1 + sovGame(uint64(m.MapDepth))
	}
	if m.MapKill != 0 {
		n += 1 + sovGame(uint64(m.MapKill))
	}
	if m.MapIsKillBoss != 0 {
		n += 1 + sovGame(uint64(m.MapIsKillBoss))
	}
	if m.ShowX != 0 {
		n += 1 + sovGame(uint64(m.ShowX))
	}
	if m.ShowY != 0 {
		n += 1 + sovGame(uint64(m.ShowY))
	}
	return n
}

func (m *C_GetBagItems) Size() (n int) {
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovGame(uint64(m.PlayerId))
	}
	return n
}

func (m *BagItem) Size() (n int) {
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovGame(uint64(m.ItemId))
	}
	if m.BagSlotId != 0 {
		n += 1 + sovGame(uint64(m.BagSlotId))
	}
	l = len(m.CurCnt)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *S_GetBagItems) Size() (n int) {
	var l int
	_ = l
	if m.BagSize != 0 {
		n += 1 + sovGame(uint64(m.BagSize))
	}
	if m.MaxBagSize != 0 {
		n += 1 + sovGame(uint64(m.MaxBagSize))
	}
	if len(m.ItemList) > 0 {
		for _, e := range m.ItemList {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *C_GetEquips) Size() (n int) {
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovGame(uint64(m.PlayerId))
	}
	return n
}

func (m *EquipItem) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	if m.ItemId != 0 {
		n += 1 + sovGame(uint64(m.ItemId))
	}
	if m.SavePos != 0 {
		n += 1 + sovGame(uint64(m.SavePos))
	}
	if m.Luck != 0 {
		n += 1 + sovGame(uint64(m.Luck))
	}
	if m.MagicId != 0 {
		n += 1 + sovGame(uint64(m.MagicId))
	}
	return n
}

func (m *S_GetEquips) Size() (n int) {
	var l int
	_ = l
	if m.IsHero != 0 {
		n += 1 + sovGame(uint64(m.IsHero))
	}
	if m.HeroType != 0 {
		n += 1 + sovGame(uint64(m.HeroType))
	}
	if len(m.EquipList) > 0 {
		for _, e := range m.EquipList {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *C_GetSkills) Size() (n int) {
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovGame(uint64(m.PlayerId))
	}
	return n
}

func (m *SkillItem) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	if m.SavePos != 0 {
		n += 1 + sovGame(uint64(m.SavePos))
	}
	if m.IsLevelUp != 0 {
		n += 1 + sovGame(uint64(m.IsLevelUp))
	}
	return n
}

func (m *S_GetSkills) Size() (n int) {
	var l int
	_ = l
	if m.IsHero != 0 {
		n += 1 + sovGame(uint64(m.IsHero))
	}
	if m.HeroType != 0 {
		n += 1 + sovGame(uint64(m.HeroType))
	}
	if len(m.SkillList) > 0 {
		for _, e := range m.SkillList {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func sovGame(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGame(x uint64) (n int) {
	return sovGame(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *C_ClientLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ClientLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ClientLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Behavior", wireType)
			}
			m.Behavior = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Behavior |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_UserLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_UserLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_UserLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			m.Latitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latitude |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			m.Longitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Longitude |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accuracy", wireType)
			}
			m.Accuracy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accuracy |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ShareInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ShareInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ShareInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			m.Param = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Param |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_GetServerTime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_GetServerTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_GetServerTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_LoginServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_LoginServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_LoginServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			m.ServerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &UserInfo{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sharing == nil {
				m.Sharing = &SharingInfo{}
			}
			if err := m.Sharing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoginChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SharingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SharingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SharingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Province", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Province = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_LoginServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_LoginServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_LoginServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessionkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessionkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNew", wireType)
			}
			m.IsNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsNew |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_GameServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_GameServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_GameServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessionkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessionkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_GameServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_GameServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_GameServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_AccountInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_AccountInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_AccountInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_AccountInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_AccountInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_AccountInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Picture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Picture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ChrList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ChrList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ChrList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_ChrList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_ChrList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_ChrList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selected", wireType)
			}
			m.Selected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Selected |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerList = append(m.PlayerList, &S_ChrList_ChrPlayer{})
			if err := m.PlayerList[len(m.PlayerList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_ChrList_ChrPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChrPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChrPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_NewChr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_NewChr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_NewChr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name_", wireType)
			}
			m.Name_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Name_ |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_NewChr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_NewChr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_NewChr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_GetName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_GetName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_GetName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_GetName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_GetName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_GetName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RndName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RndName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_PlayerAbility) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_PlayerAbility: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_PlayerAbility: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseAbility) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseAbility: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseAbility: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hp", wireType)
			}
			m.Hp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HpMax", wireType)
			}
			m.HpMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HpMax |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dc", wireType)
			}
			m.Dc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dc |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcMax", wireType)
			}
			m.DcMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcMax |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mp", wireType)
			}
			m.Mp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MpMax", wireType)
			}
			m.MpMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MpMax |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sc", wireType)
			}
			m.Sc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sc |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScMax", wireType)
			}
			m.ScMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScMax |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ac", wireType)
			}
			m.Ac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcMax", wireType)
			}
			m.AcMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcMax |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			m.Mac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacMax", wireType)
			}
			m.MacMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacMax |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hit", wireType)
			}
			m.Hit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dex", wireType)
			}
			m.Dex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crit", wireType)
			}
			m.Crit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_PlayerAbility) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_PlayerAbility: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_PlayerAbility: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChrName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChrName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ability == nil {
				m.Ability = &BaseAbility{}
			}
			if err := m.Ability.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpMax", wireType)
			}
			m.ExpMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpMax |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yb", wireType)
			}
			m.Yb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Yb |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpv", wireType)
			}
			m.Cpv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpv |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			m.MapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_ChangeMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_ChangeMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_ChangeMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			m.MapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_ChangeMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_ChangeMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_ChangeMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
			}
			m.MapId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddExp", wireType)
			}
			m.AddExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddExp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddGold", wireType)
			}
			m.AddGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddGold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddInterval", wireType)
			}
			m.AddInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddInterval |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockLv", wireType)
			}
			m.UnlockLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockLv |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapAttackMode", wireType)
			}
			m.MapAttackMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapAttackMode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBossId", wireType)
			}
			m.MapBossId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapBossId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapDepth", wireType)
			}
			m.MapDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapDepth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKill", wireType)
			}
			m.MapKill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapKill |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapIsKillBoss", wireType)
			}
			m.MapIsKillBoss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapIsKillBoss |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowX", wireType)
			}
			m.ShowX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowX |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowY", wireType)
			}
			m.ShowY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowY |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_GetBagItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_GetBagItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_GetBagItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BagItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BagItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BagItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagSlotId", wireType)
			}
			m.BagSlotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagSlotId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurCnt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurCnt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_GetBagItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_GetBagItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_GetBagItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagSize", wireType)
			}
			m.BagSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBagSize", wireType)
			}
			m.MaxBagSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBagSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemList = append(m.ItemList, &BagItem{})
			if err := m.ItemList[len(m.ItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_GetEquips) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_GetEquips: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_GetEquips: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquipItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquipItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquipItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SavePos", wireType)
			}
			m.SavePos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SavePos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Luck", wireType)
			}
			m.Luck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Luck |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicId", wireType)
			}
			m.MagicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MagicId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_GetEquips) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_GetEquips: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_GetEquips: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHero", wireType)
			}
			m.IsHero = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsHero |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroType", wireType)
			}
			m.HeroType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EquipList = append(m.EquipList, &EquipItem{})
			if err := m.EquipList[len(m.EquipList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C_GetSkills) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C_GetSkills: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C_GetSkills: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SavePos", wireType)
			}
			m.SavePos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SavePos |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLevelUp", wireType)
			}
			m.IsLevelUp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsLevelUp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S_GetSkills) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S_GetSkills: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S_GetSkills: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHero", wireType)
			}
			m.IsHero = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsHero |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeroType", wireType)
			}
			m.HeroType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeroType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkillList = append(m.SkillList, &SkillItem{})
			if err := m.SkillList[len(m.SkillList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGame(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGame
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGame
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGame
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGame(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGame = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGame   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("game.proto", fileDescriptorGame) }

var fileDescriptorGame = []byte{
	// 1917 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x49, 0x93, 0xe3, 0x48,
	0x15, 0x1e, 0xab, 0x5c, 0x5d, 0xe5, 0x74, 0xbb, 0x5a, 0xa3, 0x69, 0x08, 0xc7, 0xc4, 0x4c, 0xd1,
	0x88, 0xa5, 0x9b, 0x21, 0xc6, 0x15, 0xd3, 0x9c, 0x21, 0x90, 0x55, 0x2a, 0x97, 0xa2, 0xe5, 0x05,
	0xa5, 0x3c, 0x4d, 0x9f, 0x1c, 0x59, 0x52, 0x8e, 0x2d, 0x4a, 0x1b, 0x92, 0xec, 0x76, 0xc1, 0x85,
	0x9d, 0x59, 0x38, 0x10, 0xc1, 0x2f, 0x20, 0xb8, 0x70, 0xe1, 0x4f, 0x70, 0x81, 0xe0, 0xc4, 0x4f,
	0x20, 0x9a, 0x1f, 0xc0, 0x16, 0xc0, 0x0c, 0xdb, 0x10, 0xf9, 0x32, 0xb5, 0xb8, 0xec, 0x29, 0x3a,
	0x38, 0x39, 0xbf, 0x97, 0x2f, 0xdf, 0xcb, 0xf7, 0x7d, 0x2f, 0x33, 0x65, 0x84, 0xe6, 0x24, 0xa4,
	0xbd, 0x24, 0x8d, 0xf3, 0x58, 0x39, 0x84, 0x9f, 0x61, 0x36, 0x57, 0x31, 0x6a, 0xeb, 0x33, 0x3d,
	0xf0, 0x69, 0x94, 0x5b, 0xf1, 0x5c, 0x51, 0x50, 0xf3, 0xd2, 0x8f, 0xbc, 0x6e, 0xe3, 0x5e, 0xe3,
	0x41, 0xc7, 0x86, 0xb1, 0xf2, 0x32, 0x3a, 0xbc, 0xa0, 0x0b, 0xb2, 0xf2, 0xe3, 0xb4, 0x2b, 0x81,
	0xbd, 0xc4, 0xca, 0x5d, 0xb4, 0x9f, 0x90, 0x94, 0x84, 0xdd, 0xbd, 0x7b, 0x8d, 0x07, 0x2d, 0x9b,
	0x03, 0xf5, 0x2d, 0x74, 0xa4, 0xcf, 0xa6, 0x19, 0x4d, 0xad, 0xd8, 0x25, 0xb9, 0x1f, 0x47, 0x2c,
	0x46, 0x40, 0x72, 0x3f, 0x5f, 0x7a, 0x54, 0xc4, 0x2e, 0xb1, 0xf2, 0x0a, 0x6a, 0x05, 0x71, 0x34,
	0xe7, 0x93, 0x3c, 0x41, 0x65, 0x60, 0x2b, 0x89, 0xeb, 0x2e, 0x53, 0xe2, 0x5e, 0x41, 0x92, 0x8e,
	0x5d, 0x62, 0x35, 0x64, 0x9b, 0xc7, 0x0b, 0x92, 0x52, 0x33, 0x7a, 0x2b, 0x56, 0x8e, 0x90, 0xe4,
	0x17, 0x5b, 0x97, 0x7c, 0x8f, 0x15, 0x93, 0x5f, 0x25, 0x45, 0x4c, 0x18, 0x97, 0x05, 0xee, 0xd5,
	0x0a, 0x94, 0xd1, 0xde, 0xd2, 0xf7, 0xba, 0x4d, 0x30, 0xb1, 0x61, 0x55, 0xd6, 0x3e, 0xd8, 0x44,
	0x59, 0x6f, 0xa0, 0x3b, 0x78, 0x36, 0xa0, 0x39, 0xa6, 0xe9, 0x8a, 0xa6, 0x8e, 0x1f, 0x52, 0xe5,
	0x18, 0xa1, 0xac, 0x44, 0x90, 0x7a, 0xcf, 0xae, 0x59, 0xd4, 0xdf, 0x34, 0x50, 0x47, 0x9f, 0x59,
	0xf1, 0xdc, 0x8f, 0xf8, 0x2a, 0xa5, 0x8b, 0x0e, 0x88, 0xeb, 0xc6, 0xcb, 0x28, 0x07, 0xf7, 0x96,
	0x5d, 0x40, 0x56, 0x29, 0x5f, 0x69, 0x9e, 0xc2, 0x96, 0x9b, 0x76, 0x89, 0x95, 0x1e, 0x3a, 0x5c,
	0x66, 0x34, 0x65, 0x65, 0xc2, 0xd6, 0xdb, 0x0f, 0x95, 0x5e, 0xa1, 0x61, 0x6f, 0x2a, 0x66, 0xec,
	0xd2, 0x47, 0x39, 0x41, 0x07, 0xd9, 0x82, 0xa4, 0x7e, 0x34, 0x87, 0xb2, 0xda, 0x0f, 0x3f, 0x56,
	0xb9, 0x63, 0x3e, 0x01, 0x2b, 0x0a, 0x2f, 0x45, 0x45, 0xb7, 0x03, 0xb6, 0x4b, 0x7d, 0x41, 0xa2,
	0x88, 0x06, 0x50, 0x78, 0xcb, 0xde, 0xb0, 0xa9, 0x4f, 0x50, 0xbb, 0xb6, 0xb6, 0x46, 0x77, 0xab,
	0xa0, 0x1b, 0xa8, 0x95, 0xb6, 0xa9, 0xdd, 0x83, 0x72, 0x36, 0xa9, 0x6d, 0xd6, 0x3b, 0xe6, 0x97,
	0x0d, 0x74, 0x58, 0x94, 0xc1, 0x1a, 0x82, 0xac, 0x48, 0x4e, 0xd2, 0x69, 0x1a, 0x88, 0xf8, 0x95,
	0x81, 0xa5, 0x71, 0xfd, 0xfc, 0x0a, 0xd2, 0xb4, 0x6c, 0x18, 0x33, 0x52, 0x81, 0xc3, 0xf4, 0x4a,
	0x34, 0x62, 0x01, 0x95, 0x8f, 0xa3, 0x5b, 0x73, 0x1a, 0x79, 0x34, 0x15, 0xf9, 0x04, 0xe2, 0x0d,
	0x19, 0xcd, 0x97, 0x64, 0x4e, 0x45, 0xad, 0x25, 0x66, 0x73, 0x91, 0xef, 0x5e, 0x8e, 0x48, 0x48,
	0xbb, 0xb7, 0xf8, 0x5c, 0x81, 0xd9, 0x5c, 0x92, 0xc6, 0x2b, 0x3f, 0x72, 0x69, 0xf7, 0x80, 0xcf,
	0x15, 0x58, 0xfd, 0x59, 0x03, 0x75, 0xf0, 0x86, 0xd8, 0xa2, 0xfc, 0x46, 0x55, 0x3e, 0x93, 0xdf,
	0xf3, 0x52, 0x9a, 0x65, 0xa2, 0x80, 0x02, 0xd6, 0x1b, 0x63, 0x6f, 0xb3, 0x31, 0xa0, 0xc9, 0xb2,
	0xcc, 0x8f, 0xa3, 0x4b, 0x7a, 0x25, 0xea, 0xa8, 0x59, 0x58, 0x8d, 0x29, 0xcd, 0x96, 0x41, 0x2e,
	0xda, 0x55, 0x20, 0x46, 0xb5, 0x9f, 0x8d, 0xe8, 0x53, 0x28, 0xa2, 0x69, 0x73, 0xa0, 0x7e, 0x19,
	0xdd, 0xd6, 0x67, 0x03, 0x12, 0xd2, 0x8f, 0xdc, 0xe3, 0x66, 0x3e, 0xe9, 0x7a, 0x3e, 0xf5, 0xb3,
	0xe8, 0x36, 0xae, 0x47, 0xa8, 0xf2, 0x37, 0xea, 0xf9, 0xd5, 0x4f, 0xb2, 0xde, 0xd7, 0x78, 0x11,
	0x20, 0xec, 0x56, 0x2a, 0xf5, 0x3d, 0xa0, 0xec, 0x46, 0x9f, 0x0d, 0x39, 0xa4, 0x6b, 0x72, 0x74,
	0xd1, 0x41, 0xe2, 0xbb, 0xf9, 0x32, 0xa5, 0x05, 0x69, 0x02, 0x82, 0xc0, 0xe2, 0xf6, 0x11, 0x94,
	0x95, 0xb8, 0xd6, 0x14, 0xfb, 0xf5, 0xa6, 0x50, 0x5f, 0x45, 0x2d, 0x7d, 0xa6, 0x2f, 0x52, 0xcb,
	0xcf, 0xf2, 0x1d, 0x9b, 0xfd, 0x55, 0x03, 0xb5, 0x70, 0x39, 0x0f, 0xc7, 0x35, 0xa0, 0x6e, 0x4e,
	0x8b, 0x3b, 0xa7, 0xc4, 0xca, 0x17, 0x11, 0x4a, 0x02, 0x72, 0x45, 0xc1, 0xb3, 0x2b, 0xdd, 0xdb,
	0x7b, 0xd0, 0x7e, 0xf8, 0x6a, 0xed, 0x04, 0x16, 0x41, 0x7a, 0xfa, 0x22, 0x9d, 0x80, 0xa3, 0x5d,
	0x5b, 0xf0, 0xf2, 0x0c, 0xb5, 0xca, 0x09, 0xe8, 0x38, 0x18, 0x99, 0x65, 0x9e, 0x02, 0xb3, 0x3d,
	0x66, 0x74, 0x2d, 0x4e, 0x1c, 0x1b, 0x32, 0xcb, 0xd7, 0xe2, 0x0b, 0x71, 0xbd, 0xb1, 0x21, 0x3b,
	0x2f, 0x11, 0xa3, 0x8e, 0x93, 0x00, 0x63, 0xb5, 0x8f, 0x0e, 0xf5, 0xd9, 0x88, 0x3e, 0xd5, 0x17,
	0x69, 0x11, 0xa3, 0xb1, 0x15, 0x43, 0xda, 0x8e, 0x21, 0x6e, 0x4d, 0x88, 0xf1, 0x25, 0x74, 0x88,
	0x8b, 0x18, 0x1f, 0xd1, 0x01, 0x1b, 0x7b, 0x97, 0x36, 0xf7, 0xae, 0xb6, 0x19, 0xd9, 0x03, 0x9a,
	0x33, 0x1d, 0xd5, 0xcf, 0x30, 0x66, 0x05, 0x60, 0xa2, 0xa6, 0x91, 0x07, 0x7a, 0x8b, 0x2b, 0x52,
	0x40, 0xf5, 0x75, 0x74, 0x47, 0x9f, 0x71, 0x5e, 0xb4, 0x0b, 0x3f, 0x60, 0x47, 0xff, 0x06, 0x7a,
	0xd4, 0x5f, 0x48, 0xa8, 0xdd, 0x27, 0x19, 0x2d, 0x7c, 0x8f, 0x90, 0xb4, 0x48, 0x84, 0xa2, 0xd2,
	0x22, 0x61, 0x07, 0x64, 0x91, 0x0c, 0xc9, 0x5a, 0x5c, 0xb7, 0x1c, 0x30, 0x2f, 0xcf, 0x15, 0x57,
	0x96, 0xe4, 0xb9, 0xcc, 0xcb, 0x73, 0x99, 0x57, 0x93, 0x7b, 0x01, 0x60, 0x5e, 0x61, 0x02, 0xfd,
	0xd3, 0xb4, 0xa5, 0x10, 0x62, 0x85, 0x10, 0x4b, 0x1c, 0xb6, 0xb0, 0x88, 0x95, 0xb9, 0x70, 0x51,
	0x34, 0x6d, 0x29, 0x83, 0x58, 0x19, 0xc4, 0x3a, 0xe4, 0x5e, 0x59, 0x11, 0x8b, 0xb8, 0xdd, 0x16,
	0xf7, 0x22, 0xe0, 0x45, 0xc0, 0x0b, 0x71, 0x2f, 0x00, 0x4c, 0x96, 0x90, 0xb8, 0xdd, 0x36, 0x6f,
	0xc8, 0x90, 0xb8, 0x8c, 0xf6, 0x90, 0x3b, 0xde, 0x06, 0xa3, 0x40, 0xcc, 0x73, 0xe1, 0xe7, 0xdd,
	0x0e, 0x17, 0x70, 0xe1, 0x43, 0x33, 0x7b, 0x74, 0xdd, 0x3d, 0xe2, 0x16, 0x8f, 0xae, 0xe1, 0x1a,
	0x4d, 0xfd, 0xbc, 0x7b, 0x87, 0x4b, 0xca, 0xc6, 0xea, 0xcf, 0x25, 0xf6, 0xc2, 0x3d, 0x37, 0xbf,
	0xcf, 0xd5, 0x7e, 0x77, 0xd1, 0x7e, 0x40, 0x57, 0x34, 0x10, 0xcf, 0x2b, 0x07, 0x70, 0x61, 0x2f,
	0x52, 0x90, 0x78, 0x5f, 0x5c, 0xd8, 0x1c, 0xb2, 0x97, 0x8b, 0xf0, 0xd4, 0xc0, 0xe4, 0xc6, 0xcb,
	0x55, 0xd3, 0xd2, 0x2e, 0xbc, 0x58, 0x4a, 0xba, 0x4e, 0x04, 0xc7, 0x6c, 0xc8, 0x68, 0xa1, 0xeb,
	0xa4, 0x62, 0x59, 0x20, 0x56, 0xf2, 0x3c, 0x0e, 0x3c, 0x41, 0x34, 0x8c, 0x19, 0xf5, 0x57, 0x17,
	0x82, 0x67, 0xe9, 0xea, 0x82, 0x45, 0x73, 0x93, 0x55, 0x41, 0xb2, 0x9b, 0xac, 0x40, 0x58, 0x92,
	0x98, 0x1e, 0x70, 0xdc, 0xb1, 0x39, 0x50, 0x3f, 0x05, 0xdf, 0x4d, 0x0b, 0x12, 0xcd, 0xe9, 0x90,
	0x24, 0x95, 0x53, 0xa3, 0xee, 0xf4, 0x81, 0x84, 0xda, 0xf8, 0x7f, 0x79, 0x31, 0x2e, 0x42, 0x92,
	0xd4, 0xae, 0xb7, 0x02, 0xb2, 0x42, 0x88, 0xe7, 0x19, 0xeb, 0x44, 0x10, 0x2a, 0x90, 0x78, 0x44,
	0x06, 0xac, 0x16, 0xce, 0x6a, 0x01, 0x95, 0x7b, 0xa8, 0x4d, 0x3c, 0xcf, 0x8c, 0x72, 0x9a, 0xae,
	0x48, 0x20, 0xde, 0x83, 0xba, 0x89, 0xe9, 0xb9, 0x8c, 0x82, 0xd8, 0xbd, 0xb4, 0x56, 0x40, 0x70,
	0xc7, 0x2e, 0xb1, 0xf2, 0x69, 0xd4, 0x09, 0x49, 0xa2, 0xe5, 0x39, 0x71, 0x2f, 0x87, 0xb1, 0xc7,
	0x5f, 0xb8, 0x8e, 0xbd, 0x69, 0x64, 0xcf, 0x73, 0x48, 0x92, 0x7e, 0x9c, 0x65, 0xa6, 0x07, 0x0c,
	0x77, 0xec, 0xca, 0xc0, 0xe2, 0x87, 0x24, 0x39, 0xa5, 0x49, 0xbe, 0x00, 0xa2, 0x3b, 0x76, 0x89,
	0x45, 0xa5, 0x8f, 0xfc, 0x20, 0x00, 0xc6, 0x3b, 0x76, 0x01, 0x45, 0x66, 0x33, 0x63, 0x80, 0x05,
	0x02, 0x01, 0x78, 0xe6, 0xca, 0x08, 0xa7, 0x67, 0x11, 0x3f, 0xfd, 0x6a, 0x21, 0x05, 0x80, 0xc2,
	0xfa, 0x44, 0xf4, 0x3b, 0x07, 0xea, 0xe7, 0xd9, 0xe3, 0x33, 0xa0, 0x79, 0x9f, 0xcc, 0xcd, 0x9c,
	0x86, 0xd9, 0x8d, 0x17, 0xc5, 0x63, 0x74, 0x20, 0xfc, 0x18, 0xe7, 0x7e, 0x4e, 0xc3, 0xd2, 0x49,
	0x20, 0x56, 0xf5, 0x05, 0x99, 0xe3, 0x20, 0xce, 0xcb, 0xbb, 0xac, 0x32, 0xb0, 0x55, 0xee, 0x32,
	0xd5, 0xcb, 0xb7, 0x5b, 0x20, 0x75, 0xcd, 0x9e, 0xb7, 0xfa, 0x2e, 0xba, 0xe8, 0x80, 0xad, 0xf2,
	0xbf, 0x51, 0x7c, 0x07, 0x17, 0x90, 0xbd, 0xba, 0x21, 0x59, 0xf7, 0xc5, 0x24, 0xcf, 0x50, 0xb3,
	0x28, 0xaf, 0xa3, 0x43, 0xb6, 0x15, 0x78, 0x51, 0xf6, 0xe0, 0x45, 0x79, 0xb1, 0x7e, 0x32, 0x20,
	0xbe, 0x5d, 0xba, 0xa8, 0x9f, 0x63, 0x0d, 0x3a, 0xa0, 0xb9, 0xf1, 0xf5, 0xa5, 0x9f, 0xdc, 0x5c,
	0xfd, 0x37, 0x51, 0x0b, 0xbc, 0xa0, 0xfe, 0xeb, 0x1f, 0xd1, 0x15, 0x1f, 0xd2, 0x06, 0x1f, 0x5d,
	0x74, 0x90, 0x91, 0x15, 0x9d, 0xc4, 0x99, 0x68, 0xce, 0x02, 0xb2, 0x63, 0x16, 0x2c, 0xdd, 0x4b,
	0xd1, 0x9a, 0x30, 0xe6, 0xca, 0xcf, 0x7d, 0xd7, 0xf4, 0x44, 0x4f, 0x16, 0x50, 0xcd, 0xd9, 0x11,
	0xa9, 0xf6, 0xc9, 0xd2, 0x65, 0xe7, 0x34, 0x8d, 0x4b, 0xfa, 0x01, 0xb1, 0xfd, 0x2f, 0x68, 0x1a,
	0x3b, 0xd5, 0xf7, 0x7c, 0x89, 0x95, 0x37, 0x50, 0x8b, 0xb2, 0xd5, 0x35, 0x6a, 0x5e, 0xaa, 0xa8,
	0x29, 0x4b, 0xb3, 0x2b, 0xaf, 0x92, 0x1d, 0x7c, 0xe9, 0x07, 0xc1, 0xcd, 0xec, 0x60, 0xd4, 0x02,
	0xaf, 0x9d, 0xec, 0xd4, 0x58, 0x90, 0x36, 0x59, 0x78, 0x05, 0xb5, 0xfc, 0xcc, 0x62, 0x97, 0xdd,
	0xb4, 0x38, 0xbe, 0x95, 0xa1, 0xac, 0x5a, 0xe4, 0xff, 0x3f, 0xab, 0xce, 0xd8, 0xea, 0xdd, 0x55,
	0x97, 0x5b, 0xb6, 0x2b, 0xaf, 0xd7, 0x3e, 0xdc, 0x43, 0xfb, 0xfa, 0x4c, 0x1f, 0x9e, 0x2a, 0x08,
	0xdd, 0xd2, 0x67, 0xe6, 0xc8, 0x74, 0xe4, 0x17, 0x94, 0xbb, 0xec, 0x51, 0x1d, 0x18, 0x0e, 0x36,
	0xec, 0x37, 0x0d, 0xdb, 0x31, 0x87, 0x86, 0xfc, 0xf6, 0x7d, 0x45, 0x86, 0x0b, 0xce, 0x32, 0x8d,
	0x91, 0x63, 0x8d, 0x07, 0xf2, 0x3b, 0xf7, 0xb9, 0x1f, 0xb7, 0xe8, 0xe3, 0xe1, 0x50, 0x1b, 0x9d,
	0xca, 0xef, 0xde, 0x57, 0x5e, 0x82, 0xff, 0x7a, 0xd8, 0xb0, 0xad, 0xb1, 0xae, 0x39, 0xe6, 0x78,
	0x24, 0xbf, 0x27, 0x16, 0xe3, 0x73, 0xcd, 0x36, 0xcc, 0xd1, 0xd9, 0x58, 0xfe, 0x91, 0xb0, 0x9c,
	0x1b, 0x9a, 0xed, 0xf4, 0x0d, 0xec, 0xc8, 0x7f, 0xe8, 0x29, 0x0a, 0xfc, 0x33, 0x1a, 0x0f, 0xcc,
	0x11, 0x4f, 0x2c, 0xff, 0xb1, 0xa7, 0xbc, 0x08, 0xdf, 0xa6, 0xda, 0xd0, 0x10, 0xa6, 0x3f, 0x09,
	0x37, 0x4d, 0xd7, 0xc7, 0xd3, 0x91, 0x03, 0xc1, 0xfe, 0xdc, 0x53, 0x8e, 0xe0, 0x3b, 0xed, 0xdc,
	0xb6, 0x4c, 0xec, 0xc8, 0x7f, 0xe9, 0x29, 0x1d, 0xf8, 0x9c, 0x31, 0x1e, 0xeb, 0xe7, 0xb6, 0xfc,
	0x57, 0x31, 0x3d, 0x30, 0x9c, 0x91, 0x36, 0x34, 0xe4, 0xbf, 0xf5, 0xf8, 0xc6, 0x27, 0x96, 0xf6,
	0xc4, 0xb0, 0xb5, 0xbe, 0x69, 0x99, 0xce, 0x13, 0xf9, 0xef, 0x3d, 0x51, 0xe0, 0xb9, 0x36, 0x1a,
	0x18, 0x43, 0x6d, 0x22, 0xbf, 0x2f, 0x52, 0x0d, 0x0c, 0xa7, 0xaf, 0x0d, 0x4c, 0xc7, 0x18, 0x62,
	0xf9, 0x03, 0xe1, 0x35, 0x30, 0x1c, 0xe3, 0x2b, 0x53, 0x73, 0x82, 0xe5, 0x7f, 0x54, 0x16, 0xfc,
	0xc8, 0xb4, 0x2c, 0x2c, 0xff, 0x53, 0xe4, 0x9b, 0x62, 0x83, 0x2d, 0x92, 0xff, 0x25, 0xb0, 0x76,
	0x7a, 0x0a, 0xf8, 0xdf, 0xa2, 0xaa, 0x53, 0xc3, 0x32, 0x1c, 0xee, 0xf2, 0x1f, 0x91, 0xca, 0xd1,
	0x1e, 0x19, 0xe3, 0x11, 0x44, 0x96, 0x3f, 0xec, 0x71, 0x26, 0xc1, 0x76, 0x76, 0xc6, 0x8d, 0xdf,
	0x3a, 0xe1, 0x8e, 0xa7, 0xf6, 0x78, 0x32, 0x9d, 0x70, 0xdb, 0xb7, 0x4f, 0xb8, 0xe3, 0x78, 0x64,
	0x99, 0x23, 0xc3, 0x1c, 0xe9, 0xe3, 0xa1, 0x21, 0x7f, 0xe7, 0x84, 0x17, 0x39, 0x3e, 0x3b, 0xab,
	0x59, 0xbf, 0x7b, 0xc2, 0xb7, 0x32, 0xd4, 0x26, 0xfd, 0x31, 0xc6, 0xf2, 0xbb, 0x27, 0xaf, 0xfd,
	0xa4, 0x89, 0xf6, 0x71, 0xd1, 0x01, 0xb8, 0xd6, 0x01, 0x78, 0xbb, 0x03, 0x14, 0xf8, 0x37, 0xb3,
	0x25, 0x10, 0xde, 0x16, 0x08, 0xef, 0x10, 0x08, 0x5f, 0x13, 0x08, 0x6f, 0x0a, 0x84, 0xaf, 0x09,
	0x84, 0x77, 0x0a, 0x84, 0xb7, 0x04, 0xc2, 0x3b, 0x04, 0xc2, 0x5b, 0x02, 0xe1, 0x2d, 0x81, 0xf0,
	0x35, 0x81, 0xf0, 0x35, 0x81, 0xf0, 0xb6, 0x40, 0x78, 0x87, 0x40, 0x78, 0x97, 0x40, 0x78, 0x87,
	0x40, 0x78, 0x97, 0x40, 0x78, 0xa7, 0x40, 0x78, 0x66, 0x19, 0x6f, 0x1a, 0xd6, 0x74, 0x22, 0x7f,
	0x4f, 0x2c, 0xd5, 0x1c, 0xc7, 0x36, 0xfb, 0xbc, 0x74, 0xf9, 0xfb, 0x22, 0xc7, 0x63, 0x43, 0x73,
	0xce, 0x85, 0xed, 0x07, 0x45, 0xb8, 0xa9, 0x63, 0x8d, 0xc7, 0x8f, 0x84, 0xf5, 0x87, 0x27, 0xbc,
	0xf6, 0xbe, 0x36, 0x10, 0x96, 0xb7, 0xc5, 0x5a, 0xa0, 0x42, 0xd8, 0xde, 0x11, 0x49, 0xab, 0xae,
	0xe8, 0xdf, 0xfd, 0xf5, 0xb3, 0xe3, 0xc6, 0x6f, 0x9f, 0x1d, 0x37, 0x7e, 0xf7, 0xec, 0xb8, 0xf1,
	0xe3, 0xdf, 0x1f, 0xbf, 0xf0, 0xfe, 0x4f, 0x3f, 0xd1, 0xb8, 0xb8, 0x05, 0x97, 0xc9, 0x17, 0xfe,
	0x1b, 0x00, 0x00, 0xff, 0xff, 0x4a, 0x3a, 0xa6, 0xb2, 0x39, 0x12, 0x00, 0x00,
}
